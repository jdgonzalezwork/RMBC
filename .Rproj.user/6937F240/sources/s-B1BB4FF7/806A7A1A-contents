#########################################################
## This code generates a pdf file with the figure 3###### 
## and a .tex file whith table 3 of  the manuscript###### 
#########################################################

### Install and load Packages
packages=c("tclust","RSKC","GSE","otrimle","mclust","mvtnorm",
           "ktaucenters","xtable","ellipse","dplyr"); 
for (i in 1:length(packages)){
  if (packages[i] %in% rownames(installed.packages())==FALSE){ 
         install.packages(packages[i])}
  require(packages[i], character.only = TRUE)
}

# Load the Workspace. 
load("RMBC.RData")
n=dim(Y)[1]
Yclean=Y[-outliers_index,]
trueOutliers=Y[outliers_index,]
K=2


############################################
##  1 ROBUST ESTIMACION: RMBC ##########
############################################
resultRMBC=RMBC(Y = Y,K = K)
##  resultRMBC keep the parameters estimation.

##############################################################
# 2 Classic case # ###########################################
#Chris Fraley , # Adrian E. Raftery , Scruca Et al.        ###
##############################################################
mod1= densityMclust(Y,G=K)


############################
######## 3.  OTRIMLE ############
###########################
salot=otrimle(Y,G=K)


######################################################
## 5. TCLUST_20 (ORACLE)
######################################################
saltclustOracle=tclust(Y,k=K,alpha=0.2)


#############################################
## All the estimators have been computed ####
#############################################



##############################################################
# Compute clusters for Classic Case
##############################################################
thetaNewClas.alpha=rep(0,K);
thetaNewClas.mu=vector(mode="list", length=K)
thetaNewClas.sigma=vector(mode="list", length=K)
for (j in 1:K){
  thetaNewClas.alpha[[j]]=mod1$parameters$pro[j]
  thetaNewClas.mu[[j]]=mod1$parameters$mean[,j]
  thetaNewClas.sigma[[j]]=mod1$parameters$variance$sigma[,,j]
}

# We estimate Allocation of Points to Clusters. As is stated in Sec. 5.1
# of the manuscript

salqs=qsCoreto(Y = Y,theta.alpha =   thetaNewClas.alpha,
               theta.mu =thetaNewClas.mu,theta.sigma = thetaNewClas.sigma)

indices2MCLUST=apply(salqs,1,function(x) which(x==max(x))[1])

##############################################################
# Compute clusters for RMBC
##############################################################
thetaNew.mu=resultRMBC$mu;
thetaNew.sigma=resultRMBC$Sigma;
thetaNew.alpha=resultRMBC$alpha
salqs=qsCoreto(Y = Y,theta.alpha = thetaNew.alpha,
               theta.mu = thetaNew.mu,theta.sigma = thetaNew.sigma)

nonOutliersEstimadosRMBC=estaEnGRalpha(Y = Y,theta.mu =thetaNew.mu,theta.sigma = thetaNew.sigma,
                                       nivelAlpha=0.001)
indices2RMBC=apply(salqs,1,function(x) which(x==max(x))[1])




##############################################################
# Compute clusters for Otrimle
##############################################################

tamOtrimle=salot$size[2:(K+1)]
alphaOtrimle=tamOtrimle/sum(tamOtrimle)
thetaNewOtrimle.alpha=rep(0,K);
thetaNewOtrimle.mu=vector(mode="list", length=K)
thetaNewOtrimle.sigma=vector(mode="list", length=K)
for (j in 1:K){
  thetaNewOtrimle.alpha[[j]]=alphaOtrimle[j]
  thetaNewOtrimle.mu[[j]]=salot$mean[,j]
  thetaNewOtrimle.sigma[[j]]=salot$cov[,,j]
}
salqs=qsCoreto(Y = Y,
               theta.alpha = thetaNewOtrimle.alpha,
               theta.mu = thetaNewOtrimle.mu,
               theta.sigma = thetaNewOtrimle.sigma)
nonOutliersEstimadosOtrimle=estaEnGRalpha(Y = Y,theta.mu = thetaNewOtrimle.mu,theta.sigma = thetaNewOtrimle.sigma,nivelAlpha=0.001)
indices2Otrimle=apply(salqs,1,function(x) which(x==max(x))[1])






##############################################################
# Compute clusters for TCLUST_20  (ORACLE)
##############################################################
thetaNewTclustOracle.alpha=rep(0,K);
thetaNewTclustOracle.mu=vector(mode="list", length=K)
thetaNewTclustOracle.sigma=vector(mode="list", length=K)
for (j in 1:K){
  thetaNewTclustOracle.alpha[[j]]= saltclustOracle$size[j]/sum(saltclustOracle$size)
  thetaNewTclustOracle.mu[[j]]= saltclustOracle$centers[,j]
  thetaNewTclustOracle.sigma[[j]]= saltclustOracle$cov[,,j]
}

salqs=qsCoreto(Y = Y,theta.alpha =  thetaNewTclustOracle.alpha,
               theta.mu =  thetaNewTclustOracle.mu,theta.sigma =  thetaNewTclustOracle.sigma)
nonOutliersEstimadosTclustOracle=estaEnGRalpha(
  Y = Y,theta.mu =  thetaNewTclustOracle.mu,
  theta.sigma =  thetaNewTclustOracle.sigma,
  nivelAlpha=0.001)
indices2TclustOracle=apply(salqs,1,function(x) which(x==max(x))[1])

#################################################
#################################################
#################################################
# In the following lines the performance measures of each
# estimator are computed
#################################################
#################################################
#################################################
#################################################
perf=data.frame(row.names = c("MCR","MCR0", "Specificity","Sensitivity","KL"))
#################################################


###############################################################
## Reference Estimator:   Classic Estimator in Clean Data   ###
## Chris Fraley , # Adrian E. Raftery , Scruca Et al.        ###
###############################################################
mod1= densityMclust(Yclean,G=K)
thetaNewClasRef.alpha=rep(0,K);
thetaNewClasRef.mu=vector(mode="list", length=K)
thetaNewClasRef.sigma=vector(mode="list", length=K)
for (j in 1:K){
  thetaNewClasRef.alpha[[j]]=mod1$parameters$pro[j]
  thetaNewClasRef.mu[[j]]=mod1$parameters$mean[,j]
  thetaNewClasRef.sigma[[j]]=mod1$parameters$variance$sigma[,,j]
}

salqs=qsCoreto(Y = Yclean,theta.alpha =   thetaNewClasRef.alpha,theta.mu =   thetaNewClasRef.mu,theta.sigma =   thetaNewClasRef.sigma)
indicesReference=apply(salqs,1,function(x) which(x==max(x))[1])
indicesDGP=0*as.vector(Y[,1])
indicesDGP[-outliers_index]=indicesReference



###############################################################
###############################################################
###############################################################






thetaNew.mu=resultRMBC$mu;
thetaNew.sigma=resultRMBC$Sigma
thetaNew.alpha=resultRMBC$alpha
medRMBC=medidasDePerformance(Y,indicesDGP,thetaNew.alpha,
                             thetaNew.mu,thetaNew.sigma,actualAlpha=thetaNewClasRef.alpha,
                             actualSigma=thetaNewClasRef.sigma,actualMu=thetaNewClasRef.mu,nkl=10000)
MCRs=medRMBC$mcrSinCero
MCR0s=medRMBC$mcr
Specificitys=medRMBC$specificity
Sensitivitys=medRMBC$sensitivity
KLs=medRMBC$kl[1]
todo=c(MCRs, MCR0s,Specificitys,Sensitivitys,KLs);
perf$RMBC<-todo


medTCLUSTOracle=medidasDePerformance(Y,indicesDGP,thetaNewTclustOracle.alpha,
                                     thetaNewTclustOracle.mu,thetaNewTclustOracle.sigma,actualAlpha=thetaNewClasRef.alpha,
                                     actualSigma=thetaNewClasRef.sigma,actualMu=thetaNewClasRef.mu,nkl=10000)

Specificitys=  medTCLUSTOracle$specificity
Sensitivitys=  medTCLUSTOracle$sensitivity
MCRs=medTCLUSTOracle$mcrSinCero
MCR0s=medTCLUSTOracle$mcr
KLs=medTCLUSTOracle$kl[1]
todo=c(MCRs, MCR0s,Specificitys,Sensitivitys,KLs);
perf$TCLUSTOracle<-todo


medMCLUST=medidasDePerformance(Y,indicesDGP,thetaNewClas.alpha,
                               thetaNewClas.mu,thetaNewClas.sigma,actualAlpha=thetaNewClasRef.alpha,
                               actualSigma=thetaNewClasRef.sigma,actualMu=thetaNewClasRef.mu,nkl=10000)

Specificitys=medMCLUST$specificity
Sensitivitys=medMCLUST$sensitivity
MCRs=medMCLUST$mcrSinCero
MCR0s=medMCLUST$mcr
KLs=medMCLUST$kl[1]
todo=c(MCRs, MCR0s,Specificitys,Sensitivitys,KLs);
perf$MCLUST<-todo

medOtrimle=medidasDePerformance(Y,indicesDGP,thetaNewOtrimle.alpha,
                                thetaNewOtrimle.mu,thetaNewOtrimle.sigma,actualAlpha=thetaNewClasRef.alpha,
                                actualSigma=thetaNewClasRef.sigma,actualMu=thetaNewClasRef.mu,nkl=10000)
Specificitys=medOtrimle$specificity
Sensitivitys=medOtrimle$sensitivity
MCRs=medOtrimle$mcrSinCero
MCR0s=medOtrimle$mcr
KLs=medOtrimle$kl[1]
todo=c(MCRs, MCR0s,Specificitys,Sensitivitys,KLs);
perf$Otrimle<-todo

#################################################
# the table is generated by library xtable ######
#################################################

library(xtable)
u=colnames(perf)
#u[2]="TCLUST_{0.15}"
u[2]="TCLUST_{0.20}"
colnames(perf)<-u;
rownames(perf)[2]<-"MCR_0"
captionTable="Performance of the compared clustering procedures when applied to the phy-
toplankton data. The subscript on TCLUST is the value of the trimming parameter alpha. 
The choice 0.20 corresponds to the actual known fraction of outliers in the given data
(ORACLE). textbf{MCR}:Misclassification Rate. textbf{MCR_0}: Misclassification Rate, 
taking into account K+1 clusters, where Outliers-clusters 
are considered with zero-index.  textbf{KL} Kullback-Leibler divergence."
a=xtable(perf,caption =captionTable )
print(a,type = "latex",file = "Table3.tex")
write.csv(perf,"Table3.csv",row.names= T)
######################################
## The results are ploted #############
#######################################
#######################################
dibujarEstimadoresFinales=TRUE
if(dibujarEstimadoresFinales){
  
 
  
#  par(mfrow=c(1,1)); plot(0,0)
  ancho=4
  pdf(file = "Figure3.pdf",width = 3*ancho,height =2*ancho)
#  par(mfrow=c(2,3))
  nf <- layout(matrix(c(1,1,2,2,3,3,0,4,4,5,5,0), 2, 6, byrow=TRUE),
               respect=FALSE) 
  # Reference solution
  tituloGraf=paste("Reference  (clean Data)")
  YGraf=Yclean; indicesGraf=indicesReference; theta.mu=thetaNewClasRef.mu
  nonOutliersEstimadosGraf=rep(T,length(indicesGraf))
  theta.sigma=thetaNewClasRef.sigma
  #source("auxPlotGroupsModelBasedCluster.R")
  auxPlotGroupsModelBasedCluster()
  
  tituloGraf=paste("MCLUST")
  YGraf=Y; indicesGraf=indices2MCLUST; theta.mu=thetaNewClas.mu
  nonOutliersEstimadosGraf=rep(T,length(indicesGraf))
  theta.sigma=thetaNewClas.sigma
  #source("auxPlotGroupsModelBasedCluster.R")
  auxPlotGroupsModelBasedCluster()
  
  
  
  # este trabajo (RMBC)
  tituloGraf=paste("RMBC (This work)")
  nonOutliersEstimadosGraf=nonOutliersEstimadosRMBC
  YGraf=Y; indicesGraf=indices2RMBC;
  theta.mu=thetaNew.mu
  theta.sigma=thetaNew.sigma
  #source("auxPlotGroupsModelBasedCluster.R")
  auxPlotGroupsModelBasedCluster()
  
  
  # TCLUST ORACLE
  tituloGraf=paste("TCLUST (Oracle)")
  nonOutliersEstimadosGraf=nonOutliersEstimadosTclustOracle
  indicesGraf=indices2TclustOracle;
  YGraf=Y; indicesGraf=indices2TclustOracle;
  theta.mu= thetaNewTclustOracle.mu
  theta.sigma= thetaNewTclustOracle.sigma
  #source("auxPlotGroupsModelBasedCluster.R")
  auxPlotGroupsModelBasedCluster()
  
  
  
  # OTRIMLE
  tituloGraf=paste("OTRIMLE")
  nonOutliersEstimadosGraf=nonOutliersEstimadosOtrimle
  YGraf=Y; indicesGraf=indices2Otrimle; theta.mu=thetaNewOtrimle.mu
  theta.sigma=thetaNewOtrimle.sigma
  auxPlotGroupsModelBasedCluster()
  
  dev.off()
}

