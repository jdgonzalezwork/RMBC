# Das 04-01-2018- 
# calculo simplificado de los weights, escrito en forma mas resumida. 
 
# Das 15-2-2016-

# Se le agrega funcionalidad de seleccion de k (casos sencillos). 
# Se corrigen algunos errores para el caso en que quedan clusters Vacios.
# Se incorpora la variable nstart a

# IC 27-12-2013
# Objetivo: Programar los tau Clustering, Segun el informe nro 2.
library(combinat)
## MARMOL 28-01-2013
#CONSTANTES DE CALIBRADAS PARA ERRORES NORMALES
# VIEJO #c1=.4046;#b1= .5; #c2=1.09;#b2=.1278
constC1=c(0.4060326, 0.6967063, 0.9020027, 1.0641440, 1.2067620, 1.3291415, 1.4456766, 1.5507913, 1.6457460, 1.7383173, 1.8241284,
          1.9114874, 1.9892535, 2.0684435, 2.1401309, 2.2091677, 2.2794797, 2.3474046, 2.4131069, 2.4773304)
#0.1753843
#constC1=c(0.404629,0.6944748,0.8985921,1.063144,1.204321,1.329791,1.443817,1.548994,1.647149,1.739537,1.827075,1.910406,1.99017,2.066772,2.140529,2.211772,2.280742,2.347639,2.412622,2.475882,2.537545,2.597723,2.656494,2.714016,2.770276,2.825434,2.879547,2.932612,2.984741,3.035955,3.08632,3.135869,3.184648,3.232684,3.279986,3.326633,3.372634,3.418005,3.462781,3.506981,3.550627,3.593741,3.636342,3.678449,3.720075,3.761236,3.80195,3.842231,3.88208,3.921557,3.960609,3.999286,4.037581,4.075532,4.113132,4.15039,4.187306,4.223932,4.260211,4.296178,4.331845,4.367245,4.402347,4.437173,4.471721,4.506001,4.540023,4.573796,4.60732,4.6406,4.673648,4.706454,4.739037,4.771396,4.803549,4.835481,4.867181,4.898696,4.930009,4.961124,4.992046,5.022776,5.053319,5.083678,5.113838,5.143877,5.173678,5.203352,5.232814,5.262137,5.291296,5.320304,5.34915,5.377833,5.406382,5.434777,5.463004,5.491069,5.519042,5.546857,5.574513,5.602029,5.629455,5.656713,5.683843,5.710848,5.737726,5.764478,5.791107,5.817614,5.844001,5.870269,5.89642,5.922455,5.948373,5.974178,5.999901,6.025461,6.05095,6.076328,6.101599,6.126763,6.151823,6.176781,6.201638,6.226395,6.251055,6.275624,6.300084,6.324457,6.348727,6.372907,6.397029,6.421037,6.444946,6.468764,6.492492,6.516168,6.539737,6.563222,6.586623,6.609943,6.63318,6.656336,6.679371,6.702367,6.725285,6.748124,6.770886,6.793581,6.816188,6.83873,6.861204,6.883556,6.905896,6.928129,6.950294,6.972394,6.994428,7.016405,7.038284,7.060111,7.081862,7.103564,7.12519,7.146749,7.168252,7.189681,7.211047,7.232349,7.253587,7.274746,7.295884,7.316926,7.337911,7.358844,7.379737,7.400556,7.421316,7.442017,7.462661,7.483248,7.503778,7.524252,7.54467,7.565039,7.585339,7.605592,7.625797,7.645945,7.666039,7.68608,7.706069,7.726007,7.74591,7.765748,7.785535,7.805273,7.82496,7.844558,7.864147,7.883689,7.903179,7.922623,7.942019,7.961367,7.980669,7.999924,8.019132,8.038295,8.057414,8.076486,8.095513,8.114495,8.133433,8.152326,8.171176,8.189983,8.208746,8.227467,8.246149,8.264782,8.283357,8.301944,8.320429,8.338918,8.35733,8.375742,8.394071,8.412383,8.430632,8.448894,8.46707,8.485221,8.503334,8.521408,8.539443,8.557449,8.575411,8.593294,8.61118,8.629047,8.646855,8.664627,8.682362,8.700059,8.717721,8.735375,8.752975,8.7705,8.788031,8.805526,8.822969,8.840417,8.857788,8.875119,8.892458,8.909744,8.926998,8.94422,8.961409,8.978539,8.995658,9.012743,9.029797,9.046818,9.063807,9.080764,9.097691,9.114586,9.131449,9.148281,9.165083,9.181853,9.198593,9.215303,9.231982,9.248631,9.265251,9.28184,9.2984,9.314931,9.331432,9.347904,9.364348,9.380762,9.397148,9.413505,9.429834,9.446134,9.462407,9.478651,9.494868,9.511057,9.527219,9.543353,9.55946,9.57554,9.591593,9.607619,9.623618,9.639591,9.655538,9.671458,9.687352,9.70322,9.719062,9.734879,9.75067,9.766435,9.782175,9.797895,9.813593,9.829224,9.84487,9.86049,9.876084,9.891652,9.907196,9.922714,9.938208,9.953677,9.969121,9.984542,9.999938,10.01531,10.03066,10.04598,10.06129,10.07656,10.09182,10.10705,10.12226,10.13745,10.15261,10.16776,10.18288,10.19798,10.21304,10.22809,10.24312,10.25813,10.27312,10.2881,10.30303,10.31794,10.33285,10.34773,10.3626,10.37743,10.39222,10.40702,10.42181,10.43656,10.45129,10.46599,10.48068,10.49537,10.51,10.52463,10.53923,10.55382,10.56839,10.58294,10.59746,10.61197,10.62646,10.64092,10.65537,10.6698,10.68421,10.6986,10.71297,10.72732,10.74165,10.75597,10.77026,10.78454,10.79879,10.81303,10.82725,10.84145,10.85564,10.8698,10.88395,10.89807,10.91218,10.92627,10.9403,10.95436,10.96841,10.98243,10.99643,11.01041,11.02437,11.03832,11.05225,11.06617,11.08006,11.09393)
constC1[20]=7.844558;


b1=0.5;
#eff 0.85
constC2=c(0.9162209, 1.0605254, 1.3055369, 1.4505485, 1.5629907, 1.6809720 ,1.7862458, 1.8750228,
1.9551965, 2.0334525, 2.1092419, 2.1783367, 2.2494863, 2.3143718, 2.3854078, 2.4416526,
2.5025436, 2.5612549, 2.6151758, 3.6667671)
constC2[20]=10.52922;

#constC2=c(0.9878316,1.078572,1.170159,1.252313,1.325354,1.391451,1.452413,1.509102,1.562788,1.613542,1.662515,1.7097,1.754578,1.798178,1.840369,1.881318,1.921126,1.959779,1.997409,2.034088,2.069841,2.104731,2.138741,1.592542,2.204563,1.683028,2.267373,1.769742,2.327687,1.851155,2.385078,1.934106,2.440269,2.012693,2.493112,2.089259,2.543599,2.164328,2.591878,2.238058,2.637887,2.310871,2.681469,2.383078,2.722428,2.455193,2.760431,2.527731,2.795163,2.601879,2.824713,2.836726,2.845379,2.77153,2.83227,2.860722,2.880675,2.911201,2.934189,2.958614,2.984974,3.007076,3.031443,3.054047,3.076325,3.101141,3.129494,3.149372,3.171883,3.192948,3.21487,3.237245,3.261019,3.299004,3.315582,3.324357,3.34594,3.363809,3.387572,3.410019,3.430457,3.453253,3.475063,3.490658,3.514326,3.535696,3.555645,3.574726,3.595696,3.613739,3.634641,3.653121,3.671416,3.691476,3.71048,3.729273,3.749175,3.769304,3.787667,3.805964,3.826779,3.844296,3.860118,3.875801,3.89142,3.91718,3.936065,3.953454,3.970777,3.989486,4.009242,4.018814,4.040519,4.060497,4.078896,4.093216,4.111203,4.128169,4.145356,4.161917,4.178711,4.194473,4.215264,4.231654,4.248005,4.264274,4.280476,4.296638,4.311639,4.326066,4.340364,4.362619,4.378447,4.394218,4.409937,4.425603,4.441213,4.456771,4.473134,4.488529,4.505174,4.520384,4.535532,4.550729,4.567769,4.583046,4.598264,4.613466,4.628604,4.645812,4.660757,4.675647,4.690501,4.705308,4.72009,4.734807,4.749425,4.764066,4.778663,4.793219,4.807731,4.822209,4.836633,4.851023,4.865372,4.879681,4.893951,4.908183,4.922376,4.936531,4.951996,4.965964,4.979929,4.99383,5.007698,5.021529,5.03461,5.048251,5.062879,5.074983,5.093828,5.107495,5.121125,5.134719,5.148279,5.161803,5.175293,5.188749,5.202171,5.215558,5.228913,5.242232,5.255522,5.268773,5.281991,5.295177,5.308331,5.321454,5.334545,5.347604,5.360633,5.373631,5.386599,5.399536,5.412443,5.425321,5.438175,5.451001,5.463799,5.476568,5.489308,5.50202,5.51469,5.527359,5.539986,5.552586,5.565159,5.577704,5.590222,5.604978,5.617413,5.629821,5.642201,5.654556,5.666883,5.679184,5.691459,5.703707,5.715929,5.728126,5.740296,5.752442,5.764562,5.776657,5.788727,5.800772,5.812792,5.824788,5.836758,5.848704,5.860625,5.872523,5.884397,5.896247,5.908074,5.919877,5.931657,5.943414,5.955148,5.966859,5.978548,5.990214,6.001858,6.013479,6.025079,6.036657,6.048213,6.059747,6.07126,6.082751,6.0942,6.10567,6.117097,6.128504,6.13989,6.151256,6.162603,6.173929,6.186318,6.19759,6.208842,6.220086,6.23128,6.242475,6.253646,6.264798,6.275929,6.287041,6.298133,6.309393,6.32026,6.331294,6.34231,6.353306,6.364283,6.375241,6.386181,6.397102,6.408005,6.418889,6.429754,6.440602,6.451431,6.462242,6.473035,6.48381,6.494567,6.505306,6.516028,6.526732,6.537418,6.548087,6.558739,6.569374,6.579992,6.590592,6.601176,6.611743,6.622293,6.632826,6.643343,6.653843,6.664327,6.674781,6.68526,6.69568,6.706099,6.716502,6.726888,6.737259,6.748085,6.758403,6.76875,6.779044,6.789332,6.799595,6.80985,6.82009,6.830315,6.840525,6.85072,6.860899,6.871064,6.881213,6.891348,6.901467,6.911572,6.921662,6.931738,6.941799,6.951845,6.961877,6.971894,6.981897,6.991886,7.00186,7.01182,7.021766,7.031699,7.041617,7.051521,7.061411,7.071287,7.081214,7.09106,7.100893,7.110712,7.120518,7.13031,7.140089,7.149854,7.159606,7.169344,7.17907,7.188782,7.198481,7.208167,7.21784,7.227492,7.237158,7.2468,7.256429,7.26616,7.275759,7.285322,7.294914,7.304453,7.314015,7.32355,7.333072,7.342581,7.352079,7.361564,7.371037,7.380498,7.389947,7.399383,7.408808,7.41822,7.427621,7.43701,7.446387,7.455752,7.465106,7.474448,7.483778,7.493097,7.502404,7.511699,7.520983)

#eff 0.8

constb2=c( 0.1753843, 0.2610594, 0.2704212, 0.2891384, 0.3072014, 0.3229057, 0.3365720, 0.3500954,
 0.3613282, 0.3698560, 0.3786911, 0.3864194, 0.3952010, 0.4015180, 0.4064074, 0.4146517,
 0.4174006, 0.4229056, 0.4266953, 0.430554)
#constb2=c(0.153617,0.257078,0.3275992,0.3813169,0.4253162,0.4626414,0.4948793,0.5232686,0.5482779,0.5707572,0.5906962,0.6086252,0.6252662,0.6403455,0.6542146,0.6670029,0.678842,0.6898977,0.7002315,0.7099184,0.7190445,0.7276619,0.7358538,0.971247,0.7509845,0.9695164,0.7648372,0.9678492,0.7774973,0.9666166,0.7894387,0.964561,0.8005325,0.9628694,0.8110241,0.9611317,0.8210554,0.9592774,0.8306729,0.9573035,0.8399912,0.9551443,0.8491384,0.9527537,0.8582329,0.9500282,0.8674186,0.9468556,0.8768,0.9429489,0.8869817,0.8925952,0.8989866,0.9285006,0.9194991,0.9192199,0.9212094,0.9202222,0.9212221,0.9217575,0.9217092,0.9227273,0.9230797,0.9238298,0.9245989,0.9246586,0.9237665,0.92498,0.9254682,0.9262627,0.9267908,0.9271585,0.9271404,0.9236038,0.9252825,0.9287511,0.9290881,0.9302512,0.929999,0.9300183,0.9304649,0.9303355,0.9303993,0.9318327,0.9314123,0.9314775,0.9318287,0.9323388,0.9324022,0.9330752,0.9330964,0.9336123,0.934137,0.9342572,0.9345754,0.9349109,0.9349892,0.9349968,0.9353479,0.9356873,0.9354875,0.9359406,0.9367112,0.9374799,0.9382323,0.9369519,0.93702,0.9373647,0.9377011,0.9377462,0.9375695,0.939344,0.9387588,0.9384896,0.9385075,0.9392843,0.9393462,0.9395842,0.939764,0.9400442,0.9402646,0.9406589,0.9401134,0.9403638,0.9406058,0.9408476,0.9410865,0.9413181,0.9417426,0.9422526,0.9427682,0.9418683,0.9420912,0.9423106,0.9425261,0.9427381,0.9429471,0.9431526,0.9432081,0.9434178,0.9434031,0.9436216,0.943839,0.9440367,0.9439145,0.944078,0.9442407,0.9443954,0.9445506,0.9443546,0.9445227,0.9446897,0.9448528,0.9450139,0.9451693,0.945326,0.9454891,0.9456394,0.9457876,0.9459336,0.9460776,0.9462184,0.9463592,0.946497,0.9466328,0.9467667,0.9468985,0.9470284,0.9471563,0.9472825,0.9472006,0.9473408,0.9474737,0.947609,0.9477419,0.9478731,0.9481093,0.9482543,0.9482454,0.9486043,0.9479581,0.9480738,0.9481884,0.9483016,0.9484136,0.9485242,0.9486335,0.9487416,0.9488484,0.948954,0.9490584,0.9491619,0.9492637,0.9493653,0.9494657,0.949565,0.9496632,0.9497603,0.9498563,0.9499513,0.9500452,0.9501381,0.95023,0.9503208,0.9504106,0.9504994,0.9505864,0.9506723,0.9507571,0.950841,0.950924,0.9510061,0.951089,0.9511675,0.9512469,0.9513254,0.9514031,0.9514799,0.9515558,0.9513302,0.9514092,0.9514875,0.9515652,0.9516419,0.9517181,0.9517935,0.9518682,0.9519423,0.9520157,0.9520884,0.9521605,0.9522319,0.9523027,0.9523729,0.9524424,0.9525113,0.9525796,0.9526473,0.9527145,0.9527812,0.9528473,0.9529129,0.9529779,0.9530423,0.9531062,0.9531695,0.9532323,0.9532945,0.9533562,0.9534174,0.9534781,0.9535383,0.9535979,0.9536571,0.9537157,0.9537738,0.9538314,0.9538886,0.9539452,0.9540014,0.9540597,0.9541124,0.9541672,0.9542216,0.9542755,0.9543288,0.9543816,0.9544339,0.9543573,0.9544107,0.9544636,0.9545147,0.9545688,0.9546201,0.9546715,0.9547226,0.9547732,0.9548235,0.9548735,0.9549013,0.9549722,0.9550211,0.9550696,0.9551177,0.9551655,0.955213,0.9552601,0.9553069,0.9553534,0.9553996,0.9554454,0.9554909,0.9555361,0.955581,0.9556256,0.9556699,0.9557139,0.9557576,0.9558011,0.9558442,0.955887,0.9559296,0.9559719,0.9560138,0.9560555,0.9560969,0.9561381,0.9561789,0.9562195,0.9562598,0.9562999,0.9563397,0.9563792,0.9564199,0.9564559,0.9564962,0.9565347,0.956573,0.956611,0.9566487,0.9566356,0.9566752,0.9567098,0.9567482,0.9567853,0.9568232,0.95686,0.9568966,0.9569329,0.956969,0.9570049,0.9570405,0.957076,0.9571112,0.9571462,0.957181,0.9572156,0.95725,0.9572842,0.9573182,0.957352,0.9573856,0.957419,0.9574522,0.9574853,0.9575181,0.9575507,0.9575832,0.9576155,0.9576476,0.9576795,0.9577112,0.9577427,0.9577676,0.9577991,0.9578303,0.9578614,0.9578924,0.9579231,0.9579537,0.9579841,0.9580144,0.9580445,0.9580745,0.9581043,0.9581339,0.9581633,0.9581927,0.9582226,0.9582496,0.9582778,0.9583057,0.9583221,0.9583503,0.9583805,0.9584065,0.9584364,0.9584625,0.9584901,0.9585175,0.9585448,0.9585719,0.9585989,0.9586257,0.9586524,0.958679,0.9587054,0.9587317,0.9587579,0.9587839,0.9588098,0.9588355,0.9588612,0.9588866,0.958912,0.9589372,0.9589623,0.9589873,0.9590122,0.9590369)

# eff 0.90
# constC2= c(0.975394, 1.134499, 1.366000, 1.523652, 1.639202, 1.751003, 1.850226, 1.937850, 2.024971,
#  2.101203, 2.174260, 2.248929, 2.316660, 2.379176, 2.442779, 2.503824, 2.563290, 2.616267,
#  2.673176, 2.733373)
#
# eff 0.90
#constb2=c(0.1555909, 0.2361201, 0.2451221, 0.2641353 ,0.2850648, 0.3006291 ,0.3139925, 0.3260650,
#0.3378306, 0.3480227 ,0.3581282 ,0.3639263 ,0.3729746, 0.3789136, 0.3858586, 0.3916641,
#0.3970068, 0.4032702, 0.4088827, 0.4113436)

#eff 0.95
# constb2=c(0.1289065, 0.1967553, 0.2088382, 0.2326300, 0.2512899, 0.2676108, 0.2840588, 0.2951399,
# 0.3066808, 0.3184990, 0.3257872, 0.3328220, 0.3400733, 0.3469075, 0.3559113, 0.3585880,
# 0.3663026, 0.3730566, 0.3753926, 0.3815806)
# ## eff 0.95
# constC2=c(1.097664, 1.251966, 1.474328, 1.623721, 1.744851, 1.855444, 1.952373, 2.042702, 2.123195,
# 2.206458, 2.272256, 2.351320, 2.417818, 2.486119, 2.556576, 2.608380, 2.675405, 2.725289,
# 2.780528, 2.840991)


#eficiencia de  0.80
# constb2=c( 0.1914, 0.2874, 0.2916, 0.3101, 0.3271, 0.3429, 0.3582, 0.3698, 0.3799, 0.3888, 0.3965, 0.4049,
#  0.4114, 0.8147, 0.4240, 0.4298, 0.4354, 0.4391, 0.4444, 0.4479)
# constc2=c(0.8705345, 1.0114642, 1.2464030, 1.3995929, 1.5302470, 1.6389664, 1.7254676, 1.8192504,
#  1.9022711, 1.9834424, 2.0610830, 2.1301796, 2.2003129, 1.5050794, 2.3285809, 2.3914988,
#  2.4464672, 2.5100789, 2.5593917, 2.6197326)



#  MATIAS SALIBIAN BARRERA et al.
rhoOpt <- function(x, cc)
{
  tmp <- x^2 / 2 / (3.25*cc^2)
  tmp2 <- (1.792 - 0.972 * x^2 / cc^2 + 0.432 * x^4 / cc^4 - 0.052 * x^6 / cc^6 + 0.002 * x^8 / cc^8) / 3.25
  tmp[abs(x) > 2*cc] <- tmp2[abs(x) > 2*cc]
  tmp[abs(x) > 3*cc] <- 1
  tmp
}
#-----------------------------------------------------------------------------------



#-----------------------------------------------------------------------------------


# CODIGO desarrollado por mi, (y mas rapido) 
Mscale <- function(u, b=0.5, c, initialsc) 
{ # Solo esta pensada para b=0.5, faltaria 
  # hacer la adaptacion para cualquier valor de b. 
  
  sn=median(abs(u))/.6745
  if (sn==0){return(sn)}
  cant=mean(rhoOpt(u/sn,cc=c))-b # me indica si estoy a la derecha o de la solucion
  while (cant>0){
    sn=1.5*sn
    cant=mean(rhoOpt(u/sn,cc=c))-b # me indica si estoy a la derecha o de la solucion
  }
  
  if (cant==0){return(sn)}
  i<-0
  err <- 1
  while  (( i < 1000 ) & (err > 1e-10)) {
    var=  u/sn;
    A=mean(rhoOpt(var,cc=c));
    B=mean(psiOpt(var,cc=c)*var);
    factorAB=(A -B -b)/(2*A-B-2*b);
    snmas1 = sn*factorAB; 
    err <- abs(snmas1/sn - 1)
    sn=abs(snmas1)  
    i  <- i+1
  }
  return(sn)
}  




derpsiOpt<- function(x, cc){
  tmp <- rep(1,length(x)) / (3.25*cc^2) # derivo x^1
  #tmp2 <- (-1.944 * x / cc^2 + 1.728 * x^3 / cc^4 - 0.312 * x^5 / cc^6 + 0.016 * x^7 / cc^8) / 3.25
  # derivo lo de arriba !! 
  ##tmp2 <- (-1.944/ cc^2 + (3*1.728) * x^2 / cc^4 - (5*0.312) * x^4 / cc^6 + (7*0.016) * x^6 / cc^8) / 3.25
  tmp2 <- (-1.944/ cc^2 + (5.184) * x^2 / cc^4 - (1.56) * x^4 / cc^6 + ( 0.112) * x^6 / cc^8) / 3.25
  tmp[abs(x) > 2*cc] <- tmp2[abs(x) > 2*cc]
  tmp[abs(x) > 3*cc] <- 0
  tmp
}

psiOpt <- function(x, cc)
{
  tmp <- x / (3.25*cc^2)
  tmp2 <- (-1.944 * x / cc^2 + 1.728 * x^3 / cc^4 - 0.312 * x^5 / cc^6 + 0.016 * x^7 / cc^8) / 3.25
  tmp[abs(x) > 2*cc] <- tmp2[abs(x) > 2*cc]
  tmp[abs(x) > 3*cc] <- 0
  tmp
}


rhoOpt <- function(x, cc)
{
  tmp <- x^2 / 2 / (3.25*cc^2)
  tmp2 <- (1.792 - 0.972 * x^2 / cc^2 + 0.432 * x^4 / cc^4 - 0.052 * x^6 / cc^6 + 0.002 * x^8 / cc^8) / 3.25
  tmp[abs(x) > 2*cc] <- tmp2[abs(x) > 2*cc]
  tmp[abs(x) > 3*cc] <- 1
  tmp
}




miCER=function(ind1,ind2){
  # LA DE yummi kONDO ES UN POCO MEJOR
  nn=length(ind1)
  cer = 0; 
  for (i in 1:(nn-1)){
    for (j in (i+1):nn){
      cer=cer +  abs((ind1[i]==ind1[j]) - (ind2[i]==ind2[j]))
    }
  }
  return(cer/(nn*(nn-1)/2))  
}  

miCERLenta=function(ind1,ind2){
  #supongo que es lenta debido a que trabaja con arreglos de gran dimension. 
  #   ind1=c(1,2,3)
  #   ind2=c(2,2,3)
  nn=length(ind1)
  I1=matrix(0,ncol=nn,nrow=nn)
  I2=matrix(0,ncol=nn,nrow=nn)
  for (i in 1:(nn-1)){
    for (j in (i+1):nn){
      I1[i,j]=(ind1[i]==ind1[j])
      I2[i,j]=(ind2[i]==ind2[j])
    }
  }
  return(sum(abs(I1-I2))/(nn*(nn-1)/2))
}

tauClusteringAux=function(X,K,centro,tolmin,NiterMax){
  ############## Entrada############### 
  #X en R^nxp
  #K el numero de clusters
  # centro= una matriz de Kxp indicando los K centros
  # tolmin la tolerancia entre la diferencias de centros en el paso iterativo. 
  # NiterMax el numero maximo de iteraciones (si no se llega a la tolerancia deseada)
  ##################################################
  ################################################
  ###################Salida##########################
  ###################################################
  ####################################################
  
  # tautodo= sucecion de esacalas tau. 
  # niter= cantidad de pasos que hizo el algoritmo. 
  # centro= sistema de centros que encontro el algoritmo. 
  # clusterInfo= informacion acerca de como estan agrupados los x_i
  # anomalo=  acerca de si algun grupo quedo vacio! 
  # pesos pesos encontrado por el algoritmo. 
  anomalo=FALSE
  fueAlgunaVezAnomalo=FALSE
  n=nrow(X);
  p=ncol(X);
  if (p >20){
    c1=constC1[20]
    b1= .5 
    c2=constC2[20] 
    b2=constb2[20]
    #return("this algorithm is not calibrated for p >20")
  }  
  if (p<21){
      c1=constC1[p]
#      c1=constC1[2]
      b1= .5 
#     c2=constC2[2]
      c2=constC2[p]
      b2=constb2[p]
  }
  # defino funciones abreviadas.
  psi1=function(z){psiOpt(z, cc=c1)}
  psi2=function(z){psiOpt(z, cc=c2)}
  rho1=function(z){rhoOpt(z, cc=c1)}
#  rho2=function(z){psiOpt(z, cc=c2)}
  rho2=function(z){rhoOpt(z, cc=c2)}
  
  tautodo=c(); 
  niter=0;
  tol=tolmin+1
  MatrizConCentrosRepetidos=matrix(0,ncol=p,nrow=n)
  distancias=matrix(0,ncol=K,nrow=n)
  while((niter<NiterMax) & (tol>tolmin)){
    
    for (h in 1:K){
      
      for (iw in 1:n){ 
        MatrizConCentrosRepetidos[iw,]=centro[h,] 
      }
      
      # a cada fila de x le resto el centroide y despues calculo la distancia
      # resultado: una matriz donde en cada fila tiene di1 di2  diK, donde 
      # dij es la distancia entre xi y el centroide muj
      distancias[,h] = sqrt((X - MatrizConCentrosRepetidos)^2  %*% rep(1,p))
    }
    
    
    # ahora tomo las distancias minimas de cada elemento a los centros.
    distancias_min=apply(distancias,1,min)
    # esto es la inversa de la distancia. 
    invdi=1/distancias_min;
    # ClusterInfo es un arreglo de nx1, que contiene los enteros de 1 hasta K.
    # ClusterInfo[l] = j signifca que x_l esta asignada al cluster j. 
    clusterInfo=apply(distancias,1,function(x) which(x==min(x))[1])    
    # determino los pesos para el promedio.  
    ms=Mscale(u=distancias_min, b=b1, c=c1, initialsc=0)
    dnor=distancias_min/ms; # distancia normalizada.
    tau=ms*sqrt(mean(rhoOpt(dnor,cc=c2)))/sqrt(b2)
    # vector que acumula los valores de la escala tau de las distancias. 
    tautodo=c(tautodo,tau)
    # defino constantes coherentes con ClusteringIntroduccionVersion2013d.pdf
    Au=mean(rho2(dnor)); 
    rho2var=rho2(dnor)
    ps1=psi1(dnor);
    ps2=psi2(dnor);
    B1u=mean(ps1*distancias_min);
    B2u=mean(ps2*distancias_min);
    ###############################################################################    ###############################################################################
    ###############################################################################
    ###############################################################################
    ###############################################################################
    ########ATENCION!!!################ATENCION!!!##########ATENCION!!!########
    ########ATENCION!!!################ATENCION!!!################ATENCION!!!########
    ####ATENCION!!!#########ATENCION!!!#########ATENCION!!!#########ATENCION!!!#####
    ######ATENCION!!!################ATENCION!!!##########ATENCION!!!#####
    # 4-01-2018:defino constantes coherentes con Paper en elaboracion: (Lo dejo preparado para el futuro)   
    Du= mean(ps1*dnor);  Cu= mean(2*rho2(dnor)-ps2*dnor)
    Wni= (Cu*ps1 + Du*ps2)/dnor
    ######ATENCION!!!##############ATENCION!!!##########ATENCION!!!#####
    ########ATENCION!!!##############ATENCION!!!################ATENCION!!!########
    ####ATENCION!!!#########ATENCION!!!#########ATENCION!!!#########ATENCION!!!#####
    ######ATENCION!!!#############ATENCION!!!##########ATENCION!!!#####
    ###############################################################################
    ###############################################################################
    ###############################################################################

    
##    Wu=(2*ms*Au -B2u)/B1u
##    Wni= invdi*(Wu*ps1+ps2);
    
    
        
    # atencion!!! En este caso Si di=0. ps1=0 y ps2=0. Luego el peso wni se indefine 
    # por eso tengo que tener en cuenta  ese caso. Como \psi_1(0)=0. 
    # el peso Wni se parece a la derivada en ese caso.... 
    

    if(sum(distancias_min==0)>0){
          Wni[distancias_min==0]=(Du*derpsiOpt(0,cc=c2)+Cu*derpsiOpt(0,cc=c1))                       #(1/ms)*(ter1 + ter2)
    }
    
    pesos=0*Wni; 
    
    for (jota in 1:K){
      if ( (sum(Wni[clusterInfo==jota])) !=0 ){
        pesos[clusterInfo==jota]=Wni[clusterInfo==jota]/sum(Wni[clusterInfo==jota]);
      }
    
      if ( (sum(Wni[clusterInfo==jota]))==0 ){
        # esto significa que el algoritmo converjio.
        # entonces no  actualizo las X's.
        # pero si llega a pasar  que son cero las actualizo:
        mmm=length(clusterInfo==jota)
        if (sum(pesos[clusterInfo==jota]==0)==mmm)
          pesos[clusterInfo==jota]=1/mmm;
      }
    }
    
    
    XW=0*X
    
    #a cada fila de X la multiplico por su correspondiente peso.
    for (fila in 1:n){
      XW[fila,]=X[fila,]*pesos[fila]
    }
    
    # determino los nuevos centros. 
    centroAnterior=centro;
    # a veces una clase se queda sin elementos, por eso... 
    auxx=rep(0,K)
    for (jota in 1:K){  
      auxx[jota]=sum(clusterInfo==jota)
      if (auxx[jota]>0){
        #centro[jota,]=apply(XW[clusterInfo==jota,],2,sum) # el problema con esto 
        # es que si la matriz tenia una sola fila, se tomaba como vector y luego
        # no funcionaba la funcion apply. Por eso agregue as.matrix.
        centro[jota,]=apply(as.matrix(XW[clusterInfo==jota,]),2,sum)
      }    
    }
    
    if (sum(auxx>0)!=K){
      indicesMasLejanos= order(distancias_min,decreasing=TRUE)[1:sum(auxx==0)]; 
      centro[auxx==0,]=X[indicesMasLejanos, ]
      clusterInfo[indicesMasLejanos]=which(auxx==0)    
      fueAlgunaVezAnomalo=TRUE;
    }
    
    # la condicion sum(auxx>0)==K significa que todos los cluster estan llenos. 
    tol=sqrt(sum((centroAnterior-centro)^2));
    
    
    
    # si no estan todos llenos lo hago salir.  (BAD SOLUTION)
    #if (sum(auxx>0)!=K){
    #  anomalo=FALSE;
    #lo hago salir
    #  tol=tolmin-1
    #}
    #  y vuelvo a empezar ... 
    niter=niter+1
  } 
  salida=list(tautodo=tautodo, niter=niter, centro=centro,clusterInfo=clusterInfo,anomalo=anomalo, tol=tol,pesos=pesos,di=distancias_min,Wni=Wni,fueAlgunaVezAnomalo=fueAlgunaVezAnomalo)
  return(salida)             
}

## Le agrego la variable nstart: 


tauClustering=function(X,K,centro=NULL,tolmin=1e-06,NiterMax=100,nstart=1,startWithKmeans=TRUE){
  centroINIC=centro
  taumin=1e+20
  n=nrow(X);
  p=ncol(X);
  centro0=matrix(0,nrow=K,ncol=p)
  aa=rep(0,p)
  bb=rep(0,p)
  
  
  for (i in 1:p){
    #    aa[i]=sort(X[,i])[floor(length(X[,i])*.15)] # para GAP CONVENIA ESTO.
    #    bb[i]=sort(X[,i])[floor(length(X[,i])*.85)]
    aa[i]=sort(X[,i])[floor(length(X[,i])*.05)]
    bb[i]=sort(X[,i])[floor(length(X[,i])*.95)]
  }
  
  
  empieza=1*(!startWithKmeans); # el valor de empieza es uno o cero. 
  
  for (tirada in empieza:nstart){
    # inicializo el centro con k means.
    if (tirada==0){
      sal0=kmeans(X, centers=K,nstart = 20);
      sal0$labels=sal0$cluster;
      for (jota in 1: K){
        if (sum(sal0$labels==jota)==1){centro0[jota,]=X[sal0$labels==jota,]}
        if (sum(sal0$labels==jota)>1){centro0[jota,]=apply(X[sal0$labels==jota,],2,mean)} 
      }  
    }
    
    if (tirada>=1){
      # Esto es si quiero inicializar diferente
      for (i in 1:p){
        centro0[,i]=runif(K,aa[i],bb[i])
      }
    }
    
    if ((tirada==1) & (!is.null(centroINIC))){
      centro0=centroINIC; 
    }
    
    
  #points(centro0[1,1],centro0[1,2],lwd=4,col=6)
    centro=centro0;
    salidatau=tauClusteringAux(X=X,K=K,centro=centro,tolmin=tolmin,NiterMax=NiterMax)
    tautodo=salidatau$tautodo; 
    niter=salidatau$niter
    
    
    if (tautodo[niter]<taumin) {
      # si la escala es menor que las otras actualizo
      taumin=tautodo[niter];
      mejorTautodo=tautodo
      mejorsalidatau=salidatau
    }
  } 
  mejorsalidatau
}  


MscaleConPesosPrestablecidosPorAfuera <- function(u,pesosPrestablecidos=pesosPrestablecidos, b, c, initialsc) 
{
  # from Kristel's fastSreg
  if (initialsc==0)
    initialsc = median(abs(u))/.6745
  maxit <- 100
  sc <- initialsc
  i <- 0 
  eps <- 1e-10
  err <- 1
  while  (( i < maxit ) & (err > eps)) {
    #2017: sc2 <- sqrt( sc^2 * sum(pesosPrestablecidos*rhoOpt(u/sc,c)) / b)
    #2018:
      sc2 <- sqrt( sc^2 * mean(pesosPrestablecidos*rhoOpt(u/sc,c)) / b)
    err <- abs(sc2/sc - 1)
    sc <- sc2
    i <- i+1
  }
  
  
  return(sc)
  
}

auxPlotGroupsModelBasedCluster=function(){
  coordinates=c(1,2)
  plot(YGraf[,coordinates],
       main=tituloGraf,cex.main=3,xlab="",ylab="",lwd=1,pch=19, cex=.7, type="n",
       #xlim=c(0.5,1.2),ylim=c(0,43))
       xlim=c(0,1.1),ylim=c(0,43))
  
  # " \n ",paste("  K-L distance:",round(kl1[1],3))))#
  #,)
  library(ellipse);
  #mean(indicesGraf==1 & nonOutliersEstimadosGraf)
  #mean(indicesGraf==2 & nonOutliersEstimadosGraf)
  #mean(!nonOutliersEstimadosGraf)
  
  #################################################
  # #############si se quiere en byN###############
  # uu=gray.colors(n=3,start = 0.3,end = 0.7)
  #####################################################
  uu=c("red","cualquiercosa","green")
  
  mu1Y= theta.mu[[1]][2]
  mu2Y= theta.mu[[2]][2]
  light = which.max(c(mu1Y,mu2Y))
  dark = which.min(c(mu1Y,mu2Y))
  colors=c("","")
  symbols=c(0,0)
  colors[light]=uu[1]
  colors[dark]=uu[3]
  symbols[light]=1
  symbols[dark]=2
  for (j in 1:length(colors)){
    Ygrupo= YGraf[(indicesGraf==j) & nonOutliersEstimadosGraf,coordinates]; ngrupo=dim(Ygrupo)[1]; 
    points(Ygrupo,col=colors[j],lwd=1.5,pch=symbols[j],cex=1)
    # ejes= ellipse(theta.sigma[[j]][coordinates,coordinates],  
    #              centre = theta.mu[[j]][coordinates] ,level=0.75)
    points(theta.mu[[j]][coordinates[1]],theta.mu[[j]][coordinates[2]], pch=22, bg=colors[j],cex=4,lwd=3)
    # lines(ejes[,1],ejes[,2],lwd=4,col="blue",lty=2 )
  }
  
  points(YGraf[!nonOutliersEstimadosGraf,1],YGraf[!nonOutliersEstimadosGraf,2],lwd=4,cex=2,pch=4)
  
  for (j in 1:K){
    Ygrupo= YGraf[(indicesGraf==j) & nonOutliersEstimadosGraf,coordinates]; ngrupo=dim(Ygrupo)[1]; 
    #####  points(Ygrupo,col=j+1,lwd=3)
    ejes= ellipse(theta.sigma[[j]][coordinates,coordinates],  
                  centre = theta.mu[[j]][coordinates] ,level=0.85)
    ####points(theta.mu[[j]][coordinates[1]],theta.mu[[j]][coordinates[2]], pch=22, bg=colors[j],cex=2,lwd=2)
#    lines(ejes[,1],ejes[,2],lwd=4,col=1,lty=1 )
  }
  
  
  #length(indicesGraf)
  
  #library(ggplot2)
  #library(dplyr)
  # indicesGraf
  # 
  # datos=tibble(x1=YGraf[,1],x2=YGraf[,2],outlierEst=nonOutliersEstimados,
  #              group=as.factor(indicesGraf))
  # datos$group
  # 
  # ggplot(datos,mapping=aes(x=x1,y=x2,color=group))+
  #   geom_point()+ scale_color_grey()
  # 
  
}



